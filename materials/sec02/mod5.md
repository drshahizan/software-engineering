<a href="https://github.com/drshahizan/software-engineering/stargazers"><img src="https://img.shields.io/github/stars/drshahizan/software-engineering" alt="Stars Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/network/members"><img src="https://img.shields.io/github/forks/drshahizan/software-engineering" alt="Forks Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/pulls"><img src="https://img.shields.io/github/issues-pr/drshahizan/software-engineering" alt="Pull Requests Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering"><img src="https://img.shields.io/github/issues/drshahizan/software-engineering" alt="Issues Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/graphs/contributors"><img alt="GitHub contributors" src="https://img.shields.io/github/contributors/drshahizan/software-engineering?color=2b9348"></a>
[![Visitors](https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fgithub.com%2Fdrshahizan%2Fsoftware-engineering&countColor=%23263759&style=plastic)](https://visitorbadge.io/status?path=https%3A%2F%2Fgithub.com%2Fdrshahizan%2Fsoftware-engineering)


Don't forget to hit the :star: if you like this repo.
<!---
Module 5: Requirements Analysis and Modeling

Group Alpha
1. MAISARAH BINTI RIZAL
2. SALINI RAVINTHIRAN
3. NADHRAH NURSABRINA BINTI ZULAINI
4. NUR ALEYSHA QURRATU'AINI BINTI MAT SALLEH, A22EC0241
-->

# Module 5: Requirements Analysis and Modeling

## System Modeling
System modeling is the process of creating a simplified representation of a complex system. It involves using diagrams, mathematical equations, and other tools to define the inputs, outputs, and components of a system and to understand how they interact with each other. 
System modeling is used in a variety of fields, including engineering, physics, biology, and economics, to study and predict the behaviour of systems. By modeling a system, engineers and scientists can test different scenarios and make predictions about how the system will behave under different conditions. This can be useful for designing new systems, optimizing existing systems, and understanding the behaviour of complex systems.
System Perspectives
System perspectives are different ways of looking at a software system, each providing a distinct view of the system's structure, behavior, and interactions with its environment. A system perspective is a way of organizing and presenting information about the system, which can be useful for different purposes, such as analysis, design, implementation, or maintenance.
Some common system perspectives include:
  1.	Functional Perspective: This perspective focuses on the system's functionality, describing what the system does and how it interacts with users and other systems. The functional perspective typically includes use cases, user stories, and functional requirements.
  2.	Structural Perspective: This perspective focuses on the system's structure, describing its components, modules, and relationships. The structural perspective typically includes class diagrams, component diagrams, and package diagrams.
  3.	Behavioral Perspective: This perspective focuses on the system's behavior, describing how it responds to inputs and generates outputs. The behavioral perspective typically includes sequence diagrams, state diagrams, and activity diagrams.
  4.	Information Perspective: This perspective focuses on the system's data and information, describing the data structures, relationships, and constraints. The information perspective typically includes data models, entity-relationship diagrams, and data flow diagrams.
  5.	Deployment Perspective: This perspective focuses on the system's deployment and runtime environment, describing the hardware, software, and network infrastructure required to support the system. The deployment perspective typically includes deployment diagrams, network diagrams, and system configuration diagrams.

By using multiple system perspectives, software engineers can gain a more comprehensive and holistic understanding of the system, identifying potential design issues, and ensuring that the system meets the needs of all stakeholders. Each perspective provides a different lens through which to view the system, allowing for a deeper and more nuanced understanding of its structure, behavior, and interactions with its environment.

## Context Model
Context models are a type of modeling technique used in software engineering to capture the context of a software system. A context model shows the external environment of a system, including its actors, their goals, and the interactions between the system and its environment.
Context models help in understanding the requirements of a software system by capturing the external factors that influence its design and behavior. A context model typically consists of the following elements:
1.	Actors: These are the external entities that interact with the system. Actors can be users, other software systems, or any other external entity that interacts with the system.
2.	Goals: These are the objectives of the actors, which they try to achieve by interacting with the system. Goals can be functional, such as completing a transaction, or non-functional, such as ensuring security or privacy.
3.	Interactions: These are the ways in which the actors interact with the system to achieve their goals. Interactions can be through user interfaces, APIs, or other communication channels.
4.	Environment: This includes the external factors that influence the behavior of the system, such as hardware, software, and network infrastructure.

Context models can be represented using various modeling techniques, such as UML use case diagrams or other graphical notations. They provide a high-level view of the system's requirements and help in identifying the stakeholders, their goals, and the interactions between the system and its environment. By capturing the context of a software system, context models help in designing systems that meet the needs of the stakeholders and the external environment in which they operate.

## UML Diagram Types
UML (Unified Modeling Language) is a standard modeling language used in software engineering to visually represent software systems. There are several types of UML diagrams, each with a different purpose. Some of the most common UML diagram types include:
1.	Class Diagrams: Shows the static structure of a system by depicting the classes, attributes, methods, and relationships between objects in the system.
2.	Use Case Diagrams: Illustrates the interactions between actors (users, systems or other objects) and the system, showing how the system is used in various scenarios.
3.	Sequence Diagrams: Depicts the interactions between objects in a system, showing the messages that are passed between them over time.
4.	Activity Diagrams: Describes the flow of control in a system, showing the sequence of activities that need to be performed to achieve a specific goal.
5.	State Machine Diagrams: Depicts the behavior of a system by showing how it responds to different stimuli and how it transitions between different states.
6.	Component Diagrams: Shows the physical components of a system and their relationships, including libraries, executables, and databases.
7.	Deployment Diagrams: Shows the physical layout of a system's components and how they are deployed across different hardware nodes.

These UML diagram types can be used in combination to provide a comprehensive view of a software system's structure, behavior, and interactions with users and other systems.

## Use of Graphical Models
Graphical models have several uses in software engineering, including:
1.	Requirements Engineering: Graphical models can be used to represent the requirements of a software system, showing the relationships between different features and stakeholders.
2.	Software Design: Graphical models can be used to design the architecture of a software system, showing the components, interfaces, and relationships between different parts of the system.
3.	Testing: Graphical models can be used to generate test cases and test scenarios for a software system, showing the different possible paths through the system.
4.	Maintenance: Graphical models can be used to document the structure and behavior of a software system, making it easier to understand and modify the system over time.
5.	Code Generation: Graphical models can be used to generate code from a high-level model of a software system, reducing the amount of manual coding required.
6.	Refactoring: Graphical models can be used to identify and refactor complex parts of a software system, improving its maintainability and reducing the risk of bugs.
7.	Verification and Validation: Graphical models can be used to verify and validate a software system, showing that it meets the desired requirements and behaves correctly under different scenarios.

Overall, graphical models provide a powerful visual language for representing and understanding software systems, improving their design, development, and maintenance.

## Ways of Writing a System Requirements Specification
Writing a system requirements specification is a critical task in software engineering. A system requirements specification is a document that describes the functional and non-functional requirements of a software system. Here are some ways to write a system requirements specification:
1.	Identify stakeholders: Start by identifying the stakeholders who will be using the system or will be affected by its implementation. This will help in understanding their requirements and expectations.
2.	Define the purpose and scope: Clearly define the purpose of the system and the scope of the project. This will help in setting expectations and avoiding scope creep.
3.	Use a structured format: Use a structured format to organize the requirements, such as a table, use case diagram, or requirements traceability matrix. This will make it easier to understand and manage the requirements.
4.	Use clear and concise language: Use clear and concise language to describe the requirements. Avoid technical jargon or ambiguous terms that could lead to misinterpretation.
5.	Prioritize the requirements: Prioritize the requirements based on their importance and impact on the system. This will help in allocating resources and managing the project schedule.
6.	Use measurable criteria: Use measurable criteria to define the requirements, such as performance metrics, usability guidelines, or acceptance criteria. This will help in testing and evaluating the system.
7.	Review and revise: Review and revise the requirements specification regularly, incorporating feedback from stakeholders and updating it as the project progresses.

Overall, writing a system requirements specification requires careful planning, communication, and collaboration between stakeholders, developers, and other project team members. By following these best practices, you can ensure that the system requirements specification accurately reflects the needs of the stakeholders and provides a solid foundation for the development of the software system.

## USE CASE DIAGRAM : INTERACTION MODEL

**INTERACTION MODEL**

In software engineering, an interaction model is a design concept that describes the way that different components of a software system interact with each other. It provides a high-level view of the system's behavior and functionality, and it can be used to guide the development process and ensure that all components are working together effectively.

There are several types of interaction models that are commonly used in software engineering, including:

- **Use case diagrams:** A use case diagram describes the various interactions between actors (such as users or other systems) and the software system. It shows the different actions that users can take, as well as the system's responses to those actions.

- **Sequence diagrams:** A sequence diagram shows the interactions between different components of the software system over time. It can be used to model complex workflows or interactions between different modules or subsystems.

- **State diagrams:** A state diagram describes the different states that a system can be in and the transitions between those states. It can be used to model the behavior of a single component or the system as a whole.

Overall, interaction models are a key tool in software engineering for understanding how different components of a system interact with each other, and for ensuring that the system is designed in a way that is efficient, effective, and user-friendly.

<p align="center"><img src= "https://builtin.com/sites/www.builtin.com/files/styles/ckeditor_optimize/public/inline-images/1_interaction-model.jpg" width="400"/>

Use case modeling is a type of interaction model that is commonly used in software engineering to describe the interactions between actors (such as users or other systems) and the software system. It is a visual representation of the system's functionality from the user's perspective, and it is often used to guide the development process and ensure that the system meets user requirements.

**USE MODELING**
  
  In use case modeling, a use case diagram is used to depict the different actions that users can take and the system's responses to those actions. The diagram includes several key components:

- **Actors:** These are the different types of users or systems that interact with the software system. Actors are typically represented by stick figures in the diagram.

- **Use cases:** These are the different actions that users can take when interacting with the system. Use cases are represented by ovals in the diagram.

- **Relationships:** These are the connections between actors and use cases, and they show how the different components of the system interact with each other. Relationships are represented by arrows in the diagram.

- For example, a use case diagram for a banking application might include actors such as customers, tellers, and managers, and use cases such as "withdraw money," "deposit money," and "transfer funds." The diagram would show how each actor interacts with the system to perform these different actions.
  
<p align="center"><img src= "https://www.uml-diagrams.org/examples/use-case-example-atm.png" width="400"/>

Use case modeling is a useful tool for software engineers because it allows them to design systems that are user-centered and that meet the needs of the people who will be using the system. By modeling the different interactions between users and the system, engineers can ensure that the system is intuitive and easy to use, and that it provides users with the functionality that they need.

**Stereotypes of UML**
  
In Unified Modeling Language (UML), stereotypes are a way of extending the basic modeling elements to provide additional information or semantics. Stereotypes can be used to define new modeling elements or modify existing ones, and they are identified by a name enclosed in guillemets (<< >>).
  
  <p align="center"><img src= "https://sparxsystems.com/enterprise_architect_user_guide/16.1/images/mvc-pattern.png" width="400"/>

Stereotypes are a useful tool in UML modeling because they allow developers to extend the basic modeling elements and provide additional information or semantics. By using stereotypes, developers can create more detailed and accurate models that better reflect the complexity of the systems they are designing. However, it is important to use stereotypes judiciously and to ensure that they are properly understood by all stakeholders involved in the modeling process.

 ## STRUCTURAL MODEL
A structural model is a simplified representation of a physical system or structure that is used to study its behavior and predict its response to various stimuli or inputs. It can be in the form of a mathematical, physical, or conceptual model, and is widely used in engineering and science to design, analyze, and improve the performance of complex systems. By analyzing the response of the model to different inputs, engineers can identify potential weaknesses or failure modes in the system, and make changes to improve its safety, reliability, or efficiency. Overall, a structural model is a crucial tool for understanding and predicting the behavior of physical systems.
    
A domain model class diagram is a type of diagram used in software engineering and design to depict the classes and relationships between objects in a system. It represents the concepts, relationships, and rules of a particular domain, and is typically used to support communication between software developers and domain experts.

The notation used in a domain model class diagram is similar to that used in a UML (Unified Modeling Language) class diagram, but with some additional conventions specific to domain modeling. Some of the key elements of a domain model class diagram and their notation are:

Class: A rectangular box with the class name inside.
Attributes: A list of attributes associated with the class, with the attribute name and type separated by a colon.
Methods: A list of methods associated with the class, with the method name, parameters, and return type shown.
Association: A line connecting two classes, indicating a relationship between them.
Multiplicity: A number or range that specifies the number of instances of one class that can be associated with another class.
Inheritance: A solid line with an open arrowhead pointing from the subclass to the superclass.
Composition: A diamond shape at the end of an association line pointing to the class that is composed of the other class.
These elements and notations are used to create a visual representation of the domain model, showing the classes, attributes, methods, relationships, and rules that define the domain being modeled.
    
Class stereotypes are predefined characteristics applied to classes to indicate their roles in a system.
Some common types of class stereotypes are:
Entity: representing a persistent object that is stored in a database.
Boundary: representing the interface between the system and external actors or systems.
Control: representing a component responsible for coordinating the flow of information between other components.
Utility: representing a class with reusable methods or functions used throughout the system.
Service: representing a component responsible for providing a specific service to other components in the system. These stereotypes help communicate the purpose of classes to developers and stakeholders.
    
 

 ## BEHAVIORAL MODEL
    
A behavioral model is *a type of model that describes or predicts the behavior of a system or process*. In the context of psychology and sociology, a behavioral model is a theoretical framework that explains human behavior based on observable actions and responses to **stimuli**.

In a simple way to understand, behavioral model is a way of describing how people or animals act in certain situations. It tries to explain why we behave the way we do and what factors influence our behavior. For example, if we see someone crying, we might assume that they are sad and try to comfort them. This is because we have learned through experience that crying is often a sign of sadness. Behavioral models help us understand why we behave in certain ways and predict how we might behave in the future.

### Data-Driven Modeling

Data-driven modeling is an approach to modeling that uses data as the primary source of information for building models. In this approach, models are developed based on patterns and relationships found within the data, rather than relying solely on theoretical assumptions or expert knowledge.

   <p align="center"><img src="https://www.researchgate.net/publication/355490376/figure/fig1/AS:1082505562193925@1635100846915/Illustration-of-the-data-driven-modeling-and-optimization-approach-5-6.png" width="500">  </p>

For example, a company may use data-driven modeling to predict customer behavior and develop targeted marketing campaigns. They could collect data on customer demographics, purchasing history, and online behavior, and then use machine learning algorithms to identify patterns and relationships within the data. From this analysis, they could develop a predictive model that forecasts which customers are most likely to purchase a particular product or service.

### Activity Diagram

An activity diagram is a visual representation of a process or workflow, using symbols and arrows to show the sequence of activities and decision points involved. It is a type of flowchart that can help you understand the steps involved in a process, and identify any bottlenecks or areas for improvement.

In an activity diagram, the process is broken down into a series of activities, represented by rectangular boxes. The activities are connected by arrows that show the sequence in which they occur. Decision points are represented by diamond-shaped boxes, with multiple arrows branching out to show the different paths that the process can take based on the outcome of the decision.

Some common elements of an activity diagram include:

1.  Initial and final nodes: These represent the start and end points of the process or activity.
    
2.  Action states: These represent specific actions or activities that are performed during the process.
    
3.  Decision points: These are represented by diamond-shaped nodes and represent decision points where the flow of control may diverge based on a condition or decision.
    
4.  Fork and join nodes: These are used to represent parallel processing or concurrency in the process flow.
    
5.  Swimlanes: These are used to group related activities or actions according to the roles or departments responsible for performing them.

   <p align="center"><img src="https://online.visual-paradigm.com/images/tutorials/activity-diagram-tutorial/02-activity-diagram-samples-explained.png" width="500">  </p>

## Software Requirements Document
A Software Requirements Document (SRD) is a document that outlines the functional and non-functional requirements of a software system. It is a formal document that serves as a foundation for software development, providing a clear and concise understanding of what the software is expected to do and how it will function.
An SRD typically includes the following sections:
1.	Introduction: This section provides an overview of the software system, its purpose, and the stakeholders involved.
2.	Functional requirements: This section describes the functional requirements of the system, including the features, user interactions, inputs and outputs, and the overall behavior of the system.
3.	Non-functional requirements: This section describes the non-functional requirements of the system, such as performance, scalability, security, and usability.
4.	System architecture: This section provides an overview of the system's architecture, including its components, modules, and interfaces.
5.	System constraints: This section describes any constraints or limitations on the system, such as hardware or software limitations, regulatory requirements, or budgetary constraints.
6.	Acceptance criteria: This section outlines the acceptance criteria for the system, including how it will be tested and evaluated.
7.	Appendices: This section includes any additional information that is relevant to the system requirements, such as diagrams, use cases, or sample data.
The purpose of an SRD is to provide a clear and concise understanding of the software requirements, which helps to ensure that the software system meets the needs of the stakeholders and is delivered on time and within budget. It serves as a formal agreement between stakeholders and development teams, ensuring that everyone has a common understanding of the system's requirements and expectations. Like any software document, an SRD should be regularly reviewed and updated throughout the software development lifecycle to ensure that the requirements are still relevant and accurate.

## User and System Requirements
User requirements and system requirements are two different types of requirements in software engineering that describe different aspects of a software system.
User requirements refer to the needs, goals, and objectives of the end-users of the software system. These requirements describe what the software system should do from the perspective of the users and how it should behave. User requirements are typically elicited from user interviews, surveys, focus groups, and other techniques that involve direct engagement with the users of the software system.
Examples of user requirements include:
- The software must be easy to use and navigate for non-technical users.
- The software must be available in multiple languages to accommodate global users.
- The software must have a fast response time to prevent user frustration.

System requirements, on the other hand, refer to the technical and functional specifications of the software system. These requirements describe how the software system should function and operate, including its hardware and software components, interfaces, and interactions with other systems. System requirements are typically defined by the development team and are based on the user requirements.
Examples of system requirements include:
- The software must be compatible with Windows 10 and macOS 11.
- The software must be able to handle up to 10,000 simultaneous users.
- The software must have a RESTful API for integration with other systems.

Both user requirements and system requirements are important for the successful development of a software system. User requirements ensure that the software system meets the needs of its intended users, while system requirements ensure that the software system functions as intended and meets its technical and functional specifications.
## Users of a Requirements Document
A requirements document serves as a formal agreement between stakeholders and development teams and provides a clear and concise understanding of what the software system is expected to do, how it will function, and what its limitations are. The following are the key users of a requirements document:
1.	Clients or Customers: Clients or customers are the primary users of a requirements document as they are the ones who require a software system to be developed. They are the ones who define their needs, requirements, and expectations from the software system. A requirements document is crucial for clients to ensure that the software system meets their business goals and objectives.
2.	Project Managers: Project managers are responsible for overseeing the development of the software system and ensuring that the project is completed on time and within budget. They use the requirements document to monitor the progress of the project, make decisions, and allocate resources.
3.	Development Teams: Development teams are responsible for implementing the requirements outlined in the document. They use the requirements document to understand the scope of the project, define the technical specifications, and design and develop the software system accordingly.
4.	Quality Assurance Teams: Quality assurance teams use the requirements document to develop test plans and ensure that the software system meets the specified requirements. They use the document as a reference to ensure that the software system functions as intended.
5.	Stakeholders: Other stakeholders such as investors, regulatory bodies, and external vendors may also use the requirements document to understand the goals and objectives of the software system and ensure that it meets their expectations.

In summary, a requirements document is a critical document in software engineering that serves as a common reference point for stakeholders involved in the development of a software system. It ensures that everyone has a clear understanding of what the software system is supposed to do and how it will function, ensuring that the system meets the needs of the stakeholders and is delivered on time and within budget.
## Requirements Document Variability
Requirements document variability refers to the changes or modifications made to the requirements document throughout the software development life cycle. Variability can occur due to a variety of reasons such as changes in user needs, new regulations or policies, technological advancements, and feedback from stakeholders.
The following are some common sources of requirements document variability:
1.	Changing User Needs: User needs and expectations can change over time, which can lead to changes in the requirements document. As users gain a better understanding of what they need and want from the software system, they may request modifications to the requirements document to better align with their needs.
2.	Technological Advancements: Technological advancements can impact the functionality and features of a software system. Changes in technology may require updates to the requirements document to ensure that the software system remains up-to-date and relevant.
3.	Regulatory or Policy Changes: Changes in regulations or policies can impact the requirements of a software system. Compliance with new regulations or policies may require modifications to the requirements document.
4.	Feedback from Stakeholders: Feedback from stakeholders such as clients, project managers, development teams, and quality assurance teams can result in changes to the requirements document. Stakeholder feedback can identify gaps or deficiencies in the initial requirements document and suggest modifications to ensure that the software system meets the needs of all stakeholders.

It is important to manage requirements document variability carefully to avoid scope creep and ensure that the software development project stays within budget and on schedule. This can be achieved by having a well-defined change control process in place that includes documenting and tracking all changes made to the requirements document, obtaining approval from all stakeholders before implementing changes, and ensuring that changes are implemented in a timely and efficient manner.



