<a href="https://github.com/drshahizan/software-engineering/stargazers"><img src="https://img.shields.io/github/stars/drshahizan/software-engineering" alt="Stars Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/network/members"><img src="https://img.shields.io/github/forks/drshahizan/software-engineering" alt="Forks Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/pulls"><img src="https://img.shields.io/github/issues-pr/drshahizan/software-engineering" alt="Pull Requests Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering"><img src="https://img.shields.io/github/issues/drshahizan/software-engineering" alt="Issues Badge"/></a>
<a href="https://github.com/drshahizan/software-engineering/graphs/contributors"><img alt="GitHub contributors" src="https://img.shields.io/github/contributors/drshahizan/software-engineering?color=2b9348"></a>
![](https://visitor-badge.glitch.me/badge?page_id=drshahizan/software-engineering)

Don't forget to hit the :star: if you like this repo.

<!---
Module 5: Requirements Analysis and Modeling ME

Group PowerPuff Boys
1. Neo Zheng Weng A22EC0093
2. NICHOLAS WONG KHAI SHIAN A22EC0292
3. JOSEPH LAU YEO KAI A22EC0055

-->

# Module 5:  Requirements Analysis and Modeling 

## Contents:
### Notes
- [Overview of requirements analysis and modeling](#overview-of-requirements-analysis-and-modeling)
- [Understanding the Concept of Requirements Modeling](#a-understanding-the-concept-of-requirements-modeling)
- [Techniques for Requirements Modeling](#b-techniques-for-requirements-modeling)
- [Understanding the Requirements Document](#a-understanding-the-requirements-document)
- [Software Requirements Specification (SRS)](#b-software-requirements-specification-srs)

### Others
- [What Is Requirements Analysis and Modelling?](https://techcanvass.com/blogs/requirements-analysis-and-modelling.aspx)


<!--## Overview
This module provides an overview of the requirements analysis and modeling process in software development. Students will learn the principles of requirements analysis, techniques for requirements elicitation, and tools for requirements modeling. Students will also gain an understanding of how to validate, prioritize, and manage requirements throughout the software development lifecycle.
## Learning Objectives
By the end of this module, students will be able to:
- Understand the importance of requirements analysis in software development
- Apply techniques for eliciting requirements from stakeholders
- Use tools for modeling requirements, such as use case diagrams, activity diagrams, and state diagrams
- Validate and prioritize requirements based on stakeholder needs and constraints
- Manage changes in requirements throughout the software development lifecycle-->


## Module outline 
## I. Introduction
### Overview of Requirements Analysis and Modeling

<p align="center"><img src="https://static.wixstatic.com/media/04b97c_f2ddf302a9e940ae872dfa8145629a7c~mv2.jpg/v1/fit/w_1000%2Ch_720%2Cal_c%2Cq_80,enc_auto/file.jpg" width="700px" height="300px"/></p>

Requirements analysis is a crucial phase in the software development life cycle that involves understanding, documenting, and validating the needs of stakeholders for a software system. This phase helps to ensure that the final product meets the expectations of users, business owners, and other stakeholders.

Requirements modeling, on the other hand, involves creating a visual representation of the requirements using various techniques and tools. These models help to communicate the requirements clearly to all stakeholders and provide a basis for designing and developing the software system.

There are different approaches to requirements analysis and modeling, but some common steps include:

1. Elicitation: This involves gathering information from stakeholders to understand their needs, expectations, and constraints.

2. Analysis: This involves organizing and categorizing the requirements to identify commonalities, conflicts, and ambiguities.

3. Specification: This involves documenting the requirements in a clear and concise manner using techniques such as use cases, user stories, or functional requirements.

4. Validation: This involves reviewing and testing the requirements to ensure they are complete, correct, and consistent.

5. Modeling: This involves creating visual representations of the requirements using techniques such as data flow diagrams, entity-relationship diagrams, or use case diagrams.

Requirements modeling techniques help to represent the requirements in a way that is easy to understand for stakeholders with varying levels of technical expertise. For example, use case diagrams show the interactions between actors and the system, while data flow diagrams show how data moves through the system.

Overall, requirements analysis and modeling are critical for the success of software development projects as they ensure that the software system meets the needs of stakeholders and is delivered on time and within budget.

---

## II. Part I: Requirements Modeling Concept
### A. Understanding the Concept of Requirements Modeling
- #### What is UML Diagram & How it related to Requirements Modeling?
  
UML (Unified Modeling Language) diagram is a graphical representation of software systems, and it can be used for many purposes in software development, including requirement modeling. In requirement modeling, UML diagrams are used to visualize and document the requirements of a software system.

<p align="center"><img src="https://images.doclify.net/gleek-web/d/fbc982d6-01ee-4753-8ba1-0e828d701d5e.png?w=1200&format=webp" height="350px" width="700px"/></p>

There are several types of UML diagrams that can be used for requirement modeling, including:

1. Use Case Diagram: This type of diagram is used to describe the functionality of the system from the perspective of the users. It shows how the system interacts with the actors (users) and what functions it performs in response to their actions.

2. Activity Diagram: An activity diagram shows the flow of activities in a system or a process. It is used to model the steps that are required to perform a particular task or to achieve a specific goal.

3. Domain Diagram: A domain diagram is used to model the concepts and relationships within a specific problem domain. It is particularly useful for modeling complex systems that involve multiple interacting domains.

4. Sequence Diagram: A sequence diagram is used to show the interactions between objects in a system. It shows how objects interact with each other in a particular scenario.
  
5. State Machine Diagram: A state machine diagram is used to describe the behavior of a system or a component by showing how it responds to events and transitions between different states. It is particularly useful for modeling complex systems with a large number of states.

UML diagrams are an important tool in requirement modeling because they help to ensure that all stakeholders have a common understanding of the system requirements. They also provide a clear and concise way to communicate the requirements to the development team, which can help to avoid misunderstandings and ensure that the system is developed according to the requirements.

- #### Importance of Requirements Modeling in Software Development
Requirements modeling is a critical phase in software development that involves creating a detailed description of the desired behavior and functionality of the software system to be developed. Here are some key reasons why requirements modeling is essential in software development:

1. Establishing a common understanding: The process of requirements modeling helps establish a common understanding of the software system to be developed among all stakeholders. This includes the development team, customers, end-users, and other stakeholders. By creating a clear and comprehensive set of requirements, everyone involved in the project can have a shared understanding of what the software system should do.

2. Defining project scope: Requirements modeling helps to define the scope of the software project by clarifying what features and functionality are within the scope of the project and what are not. This helps to avoid scope creep, which can lead to increased project costs, delays, and customer dissatisfaction.

3. Minimizing rework: Requirements modeling helps to identify and correct issues early in the development process, reducing the likelihood of costly rework later. By understanding the requirements, the development team can identify potential issues or conflicts early on, reducing the risk of costly rework.

4. Improving quality: Requirements modeling helps to ensure that the software system meets the needs of its users by specifying the required functionality and behavior. This helps to improve the quality of the software system and increases the likelihood that it will be successful in the market.

5. Facilitating communication: Requirements modeling provides a common language for communication between the development team and stakeholders. This helps to ensure that everyone has a clear understanding of the software system to be developed, reducing the likelihood of misunderstandings or miscommunications.

<p align="center"><img src= "https://cs.ccsu.edu/~stan/classes/CS410/Notes16/images/05-activity_diagram_involuntary_detention.png" width="600px" height="300px"></p>

- #### Key Characteristics of Effective Requirements Models
Effective requirements models are characterized by the following key characteristics:

1. Clarity: The requirements model should be clear and concise, with unambiguous language and terminology that can be easily understood by all stakeholders. Ambiguous or unclear requirements can lead to misunderstandings and confusion, which can impact project success.

2. Completeness: The requirements model should be complete, covering all relevant aspects of the system's functionality and performance. This means that all requirements should be identified and documented, including both functional and non-functional requirements.

3. Consistency: The requirements model should be consistent, with no conflicting or contradictory requirements. Consistency ensures that all stakeholders have a clear understanding of the system's requirements and how they fit together.

4. Verifiability: The requirements model should be verifiable, meaning that each requirement can be tested to determine whether it has been satisfied. Verifiable requirements are essential for ensuring that the system meets the needs of the stakeholders.

5. Traceability: The requirements model should have traceability, meaning that each requirement can be traced back to its source and forward to the design, development, and testing stages. Traceability ensures that all requirements are met and helps with change management.

6. Prioritization: The requirements model should be prioritized, with high-priority requirements identified and given more attention than lower-priority requirements. Prioritization ensures that the most important requirements are addressed first.

7. Testability: The requirements model should be testable, meaning that each requirement can be tested to determine whether it has been satisfied. Testability is essential for ensuring that the system functions correctly and meets the needs of the stakeholders.

Overall, effective requirements models should be clear, complete, consistent, verifiable, traceable, prioritized, and testable. By ensuring these key characteristics are met, stakeholders can be confident that the system will meet their needs and be successful.

---

### B. Techniques for Requirements Modeling
### 1. INTERACTION MODEL
### Use Case Modeling and Specification

- #### What is Use Case Modeling and Specification
Use case modeling and specification is a technique used in software development to capture the functional requirements of a system by identifying and describing its interactions with actors, which could be users, other systems, or external entities.

Use case modeling involves identifying the different use cases or scenarios that a user or system might encounter when interacting with the software. Each use case is described in terms of the steps or actions that the actor takes and the responses or outcomes of the system.

Use case specification involves documenting the use cases in detail, including the actors involved, the preconditions, the steps or actions taken, the post-conditions or outcomes, and any exceptions or alternative paths that may occur.

The purpose of use case modeling and specification is to ensure that the software meets the needs of the users or stakeholders, and that it is developed according to the requirements and specifications. It helps to identify and address potential problems or issues early on in the development process, and it also provides a clear and comprehensive understanding of how the system will be used and what it is supposed to do.

- #### Basic Model Elements
The use-case model contains, as a minimum, the following basic model elements.

1. Actor:<br>
A model element representing each actor. Properties include the actors name and brief description. See Concept: Actor for more information.

2. Use Case:<br>
A model element representing each use case. Properties include the use case name and use case specification. See Artifact: Use Case and Concept: Use Case for more information.

3. Associations:<br>
Associations are used to describe the relationships between actors and the use cases they participate in. This relationship is commonly known as a “communicates-association”.

- #### Advanced model elements
The use-case model may also contain the following advanced model elements.

<ul>1. Subject:<br>
A model element that represents the boundary of the system of interest.</ul>

<ul>2. Use-Case Package:<br>
A model element used to structure the use case model to simplify analysis, communications, navigation, and planning.  If there are many use cases or actors, you can use use-case packages to further structure the use-case model in much the same manner you use folders or directories to structure the information on your hard-disk.

You can partition a use-case model into use-case packages for several reasons, including:

- To reflect the order, configuration, or delivery units in the finished system thus supporting iteration planning.
- To support parallel development by dividing the problem into bite-sized pieces.
- To simplify communication with different stakeholders by creating packages for containing use cases and actors relevant to a particular stakeholder.
- Generalizations
- A relationship between actors to support re-use of common properties.</ul>

<ul>3. Dependencies
A number of dependency types between use cases are defined in UML. In particular, <<extend>> and <<include>>.

- <<extend>> is used to include optional behavior from an extending use case in an extended use case.

- <<include>> is used to include common behavior from an included use case into a base use case in order to support re-use of common behavior.

The latter is the most widely used dependency and is useful for:

- Factoring out behavior from the base use case that is not necessary for the understanding of the primary purpose of the use case to simplify communications.
- Factoring out behavior that is in common for two or more use cases to maximize re-use, simplify maintenance and ensure consistency.</ul>

- #### Example of Use-Case Diagram
<p align="center"><img src="https://d2slcw3kip6qmk.cloudfront.net/marketing/pages/chart/what-is-a-use-case-diagram-in-UML/UML_use_case_example-800x707.PNG" width="550px" height="600px"></p>

- #### Best Practices for Creating Effective Use Case Models
Here are some best practices for creating effective use case models:

1. Involve stakeholders: Involve stakeholders from different departments or areas of expertise in the creation of the use case model. This will ensure that all requirements are captured and that the model is comprehensive.

2. Focus on the business goals: Focus on the business goals of the system and the tasks that users will perform to achieve those goals. This will help you to identify the key use cases that need to be included in the model.

3. Use clear and concise language: Use clear and concise language that is easily understood by all stakeholders. Avoid using technical jargon that may be confusing to non-technical stakeholders.

4. Define actor roles: Clearly define the roles of the actors in the use case model. This will help you to identify the key tasks that they need to perform and the interactions that they will have with the system.

5. Use templates: Use templates to standardize the format and structure of the use case model. This will make it easier to read, review, and understand.

6. Keep it simple: Keep the use case model simple and avoid overcomplicating it with unnecessary details. Focus on the key tasks and interactions that are necessary to achieve the business goals.

7. Review and validate: Review the use case model with stakeholders and validate it to ensure that it accurately reflects the business requirements. This will help you to identify any gaps or inconsistencies that need to be addressed.

By following these best practices, you can create an effective use case model that accurately reflects the business requirements and helps to ensure the success of the project.

- #### More information: 
[Use Case Diagram](https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-use-case-diagram/)

---

### 2. STRUCTURAL MODEL
### Domain Modeling and Class Diagram

- #### Domain Modeling
Domain modeling is the process of creating a conceptual representation of a particular domain or subject area. It involves identifying the entities, attributes, relationships, and behaviors that exist within the domain and creating a visual or written representation of these elements. The goal of domain modeling is to create a shared understanding of the domain that can be used to inform the design and development of software systems or other products.

Domain modeling is typically done by domain experts and software developers working together to identify the key concepts and relationships within the domain. This can involve creating diagrams, such as class diagrams or entity-relationship diagrams, or writing textual descriptions of the domain.

Domain modeling is an important step in software development because it helps ensure that the software being developed accurately reflects the needs and requirements of the domain. By creating a shared understanding of the domain, developers can create software that is more intuitive, easier to use, and better suited to the needs of its users.

When creating a domain model, we base it on the client's requirements. We can later identify the key entities and relationships between them clearly from this diagram. We draw these entities in the model as classes. The graphical notation of a class is a rectangle divided horizontally into 3 parts.
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_class_domain.png"></p>

The first part holds the name of the class, the second one contains the attributes, and we list the methods in the third part. In the domain model, we'll use only a simplified class notation with the class name and its attributes. We'll draw complete classes further in the class diagram.

The classes are connected to each other by relationships.

- #### Relationships
<ul>1. Association:<br>
An association is the basic relationship between two entities. These entities can exist independently of each other. We draw it as a simple solid line. Let's take an example of Car and Driver as a simple association between two entities. The relationship would be drawn as follows:
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_association.png"></p>

The association is bi-directional by default. That means that the first entity has a reference to the other, and the other to the first. We can change this behavior by adding a simple arrow specifying the direction of the relationship. Only the instance from which the arrow points stores the reference to the other entity in these cases. It's possible to create an association even among three classes.</ul>
  
<ul>2. Aggeragation:<br>
Aggregation represents the relationship between a whole and its parts. We draw it as a solid line with an empty diamond shape. The diamond is drawn at the class representing the whole (e.g. an article section). From the implementation point of view, this is the entity that holds the item collection. An entity representing the part can exist independently and be part of other collections. A section containing articles mentioned above could be an example of aggregation. The numbers at each end of the line specify the multiplicity. It this case, that the section contains any number of articles and the article belongs to at least 1 section.
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_aggregation.png"></p></ul>

<ul>3. Composition:<br>
A composition is similar to aggregation, but it represents a stronger relationship. The entity representing the part has no sense without the entity representing the whole. If the entity representing the whole is removed, its parts are automatically removed as well. We draw the composition relationship like the aggregation, but the diamond shape is filled. The multiplicity of the entity representing the whole must always be 1. This relationship is confusing and I'd rather avoid it and replace it with aggregation. Order and Order Item could be an example of composition. While an article without a section from the previous example would still have some meaning, an order item does not make any sense without its order. Therefore, the composition is used in this case.
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_composition.png"></p></ul>

<ul>4. Generalisation:<br>
The last relationship, we'll mention here, is generalization. In terms of implementation, it represents inheritance. One entity inherits the properties and behavior from another entity. We've already seen this kind of relationship in the use case diagram. We draw the generalization as a solid line with an empty arrow on one side (a triangle if you like). The arrow is on the side of the entity from which it's inherited. The Shape class can be an example. The Square and Circle classes could inherit from Shape.
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_generalization.png"></p></ul>

<ul>5. Multiplicity:<br>
We can specify the multiplicity for association, aggregation, and composition (for composition on one side only). Let's go back to the example with a section and an article: We read the multiplicity here as follows: A section can contain any number of articles (this is shown by the asterisk at the Article class). An Article belongs to 1 or more sections (it's shown by 1..* at the Section). 
  
Let's list available multiplicity syntax:

- 1 (number) - Indicates a specific value (1 in this example).
- '*' (asterisk) - Indicates any number (even 0). Instead of an asterisk, we can find the N symbol in some diagrams.
- 1..* (interval) - We can specify an interval with 2 dots.
- Then we use the symbols we already known, such as: 2..6 or 1..* or 0..1.

We can even mix different syntax, e.g. as: 1, 2, 3, 7..*. This would indicate numbers 1, 2, 3, or 7, or greater. If the multiplicity is not specified, it indicates the default value of 1.</ul>

- #### Best Practices for Creating Effective Domain Models
Domain modeling is the process of creating a conceptual representation of a domain that captures the essential aspects of the domain and provides a foundation for software development. An effective domain model is essential for building high-quality software that meets the needs of its users. Here are some best practices for creating effective domain models:

1. Understand the domain: The first step in creating an effective domain model is to understand the domain. This involves understanding the business or organization, the stakeholders, the problem to be solved, and the users. The better you understand the domain, the more effective your domain model will be.

2. Use a common language: Domain modeling involves creating a common language that all stakeholders can use to communicate. This language should be based on the concepts and terms used in the domain, and it should be easy to understand and use.

3. Focus on the essentials: A domain model should focus on the essential aspects of the domain. This includes the core concepts, relationships, and behaviors that are most important to the problem being solved. Don't get bogged down in unnecessary details.

4. Iterate and refine: Domain modeling is an iterative process. Start with a rough model and refine it over time as you gain a deeper understanding of the domain. Test the model with stakeholders and users to ensure it accurately represents the domain.

5. Keep it simple: A good domain model should be simple and easy to understand. Avoid unnecessary complexity and keep the model focused on the core concepts.

6. Use visual modeling tools: Use visual modeling tools, such as UML or ER diagrams, to create a clear and concise representation of the domain. This can help stakeholders and developers understand the domain model more easily.

7. Validate the model: Validate the domain model by testing it against real-world scenarios and use cases. This can help identify any gaps or inconsistencies in the model and ensure that it accurately represents the domain.

By following these best practices, you can create an effective domain model that accurately represents the domain and provides a solid foundation for software development.

- #### Class Diagram
A class diagram is a type of diagram in UML (Unified Modeling Language) that represents the structure of a system by showing the classes, their attributes, methods, and the relationships between them. The class diagram provides an overview of the system, and it is used to visualize, specify, construct, and document the architecture and design of software systems.

In a class diagram, classes are represented as rectangles with the class name written inside. The class attributes and methods are listed below the class name, with the attributes on the top and methods on the bottom. The relationships between the classes are represented as lines connecting the classes with arrows indicating the direction of the relationship. There are several types of relationships, such as inheritance, composition, and association, that can be represented in a class diagram.

Class diagrams are a useful tool for developers to visualize and understand the structure of a system, to communicate with stakeholders, and to identify potential design issues. They are often used in the early stages of software development, such as during requirements gathering and analysis, and are updated throughout the software development lifecycle.

Let's show the graphical notation of the class in UML one more time, now complete:
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_class.png"></p>
The first part of the rectangle holds the name of the class again.

In the second part, there are attributes and their data types. The access modifier is placed before each attribute. We have 4 options:
- '-' (minus) - Private attribute.
- '+' (plus) - Public attribute.
- '#' (hash cross) - Protected attribute.
- '~' (tilde) - Attribute visible from within the package.

We definitely know the meaning of the first three modifiers from the object-oriented programming. A package attribute is an attribute visible across the whole class package (namespace). We write a colon between attribute names and their data types.

The methods in the last rectangle are written in the similar way. It's possible to specify several more symbols, but we won't use them in practice much and therefore we'll omit them.

- #### Relationships
Apart from the domain model, we can use two more relationships here.

1. Interface Realisation:<br>
The realization relationship is between an interface and a class that implements this interface. The class representing the interface has a so-called stereotype. We write stereotypes enclosed in double angle quotes. We've already seen it with the <<include>> relationship in the use case diagram. Stereotypes allow us to change the meaning of a given element in a diagram. Now we're changing the class symbol to represent an interface. The class implementing the interface is connected to the
interface by an inheritance-like relationship, only the line is rendered as interrupted.
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_interface_realization.png"></p>
  
2. Association Class:<br>
Association class is a class that mediates the relationship between two entities. The advantage of such a relationship is that the association class can carry some extra attributes of the relationship. Person and Tour are often mentioned as an example, where the Participation association class assigns a person to a trip and adds
details such as whether the person paid for a lunch or when the person registered to the trip. Person and Hotel could be another example. The hotel sets no fixed time of arrival and is ordered by a particular person. A similar class could, for example, be between an employee and a firm to carry the employee's salary. Another use may be to create the M:N (many to many) relationship, similar to the one used in databases. The association class would hold a collection of references in this case. However, using an association class can be sometimes misleading, and if you're not sure, avoid it.
<p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_association_class.png"></p>
  
- #### Example of Class Diagram
  <p align="center"><img src="https://www.ictdemy.com/images/1/uml/uml_class_diagram.png"></p>

---
  
### 3. BEHAVIORAL MODEL
### Activity Diagram
  
- #### Definition and purpose of activity diagrams
Activity diagrams are “OO flowcharts” that allow us to model a process as a collection of activities and transitions between those activities:
  <ul> i. Activity diagrams are really just special cases of statecharts where every state has an entry action that specifies some process or function that occurs when the state is entered.<br>
  ii. An activity diagram can be attached to any modeling element for the purpose of modeling the behavior of that element at different abstraction levels.<br>
  iii. Activity diagrams are typically attached to: use cases, classes, interfaces, components, nodes, collaborations, operations and methods.</ul>

- #### Techniques for creating activity diagrams (e.g. actions, transitions, branches)
<p>1. <b>Transitions</b> -> indicates movements from one point to another.</p>
<p>A transition is represented by an arrow that connects the two activities, with a label indicating the conditions under which the transition can occur.Transitions  can have different types of conditions associated with them, including:
  <ul><li>Guard conditions: These are Boolean expressions that specify under what conditions the transition can occur. For example, a guard condition might specify that the transition can only occur if a certain value is greater than a certain threshold.</li>
  <li>Events: Events are signals that trigger the transition. For example, an event might be the completion of a certain activity or the receipt of a message.</li>
  <li>Timeouts: Timeouts specify a maximum time period during which the transition can occur. For example, a timeout might specify that the transition must occur within 5 seconds of the completion of the previous activity.</li></ul>
By using transitions in an activity diagram, you can model the flow of activities and the relationships between them, making it clear how the process should be executed.</p>
<p align='center'><img src="https://cdn-images.visual-paradigm.com/guide/uml/state-machine-diagram-vs-activity-diagram/01-state-machine-diagram-vs-activity-diagram.png" alt="State Machine Diagram vs Activity Diagram"></p>

  <p>2. <b>Decisions</b> -> model decision points.</p>
  <p>It is represented by a diamond-shaped symbol with multiple arrows pointing out from it, each arrow labeled with a condition that determines which path to follow.

A decision is often used to represent a choice point in the process, where different actions may be taken based on some condition. The conditions associated with    each arrow leading out from the decision must be mutually exclusive and collectively exhaustive, meaning that each possible condition must be covered by one of the    arrows.</p>
<p align='center'><img src="https://uml.blauw.me/user/pages/04.activity-diagrams/04.decisions/DecisionCaseStudy.svg" alt="State Machine Diagram vs Activity Diagram"width="600" height="450"></p>

  <p>3. <b>Fork and join</b> -> Forks split a path into two or more concurrent flows while Joins synchronize two or more concurrent flows.</p>
  <li>Fork is represented by a horizontal bar with multiple arrows pointing out from it. Each arrow represents a separate path that can be executed in parallel.</li>
  <li>Join is represented by a horizontal bar with multiple arrows pointing toward it. Each arrow represents a separate path that must complete before the process can continue down the joined path.</li>
  <li>Forks and joins are useful when there are multiple independent tasks that can be executed in parallel, and the overall process can only continue once all of these tasks have been completed. By splitting the process into parallel paths, you can often reduce the overall processing time of the activity.</li>
  <p align='center'><img src="https://i.stack.imgur.com/DRaBW.gif"width="600" height="450"></p>

  <p>4. <b>Swimlanes</b> -> partition activity diagrams.</p>
  <li>Swimlanes are represented by vertical or horizontal partitions that divide the diagram into sections, with each section assigned to a specific actor or system.</li>
  <li>Swimlanes can be used to model business processes, software systems, and other complex processes that involve multiple actors or systems. They provide a clear and concise way to show who is responsible for each activity, and help to identify potential bottlenecks or inefficiencies in the process.</li>
  <p align='center'><img src="https://wcs.smartdraw.com/swim-lane-diagram/img/vertical-swimlane-2.png?bn=15100111868" width="450" helght="600"></p>

- #### Best practices for creating effective activity diagrams
  <ul><li>Keep it simple: Activity diagrams should be simple and easy to understand. Avoid adding unnecessary details or complexity that may confuse readers. Focus on the most important aspects of the process.</li>
  <li>Use clear and concise labels: Use clear and concise labels for activities and transitions, and avoid using jargon or technical terms that may not be familiar to all readers.</li>
   <li>Use consistent notation: Use consistent notation and symbols throughout the diagram to make it easier to read and understand. Avoid using different symbols or notation for the same concept.</li>
  <li>Use swimlanes to show responsibility: Use swimlanes to show which actors or systems are responsible for each activity. This helps to identify potential bottlenecks or inefficiencies in the process.</li>
  <li>Use fork and join to show parallel processing: Use fork and join symbols to show when parallel processing is occurring. This helps to show when multiple activities are occurring simultaneously.</li>
  <li>Use decision symbols to show branching: Use decision symbols to show when the process can take different paths depending on the outcome of a decision. This helps to show when there are multiple possible outcomes for a given activity.</li>
  <li>Keep the diagram up-to-date: Keep the diagram up-to-date as the process changes over time. Review and update the diagram regularly to ensure that it accurately reflects the current process.</li>
  <li>Use appropriate tooling: Use appropriate software tools to create the activity diagram. This makes it easier to create and modify the diagram, and to share it with others.</li></ul>

---

### 4. Sequence Diagram - show object interactions arranged in a time sequence
  
- #### Definition and purpose of sequence diagrams
 <li>Sequence diagrams are part of the UML and are used to model the interactions between the actors and the objects showing their behavior within a system</li>
 <li>A sequence diagram shows the sequence of interactions that take place during a particular use case or use case instance (scenario)</li>
 <li>The objects and actors involved are listed along the top of the diagram, with a dotted line drawn vertically from these</li>
 <li>Interactions between objects are indicated by annotated arrows</li><br>

- <b>Sequence Diagram: Scope for Analysis</b>
 <li> Each use case must have at least one sequence diagram that comprises normal flow and alternative flows – split only if it is cluttered to combine all</li>
  
- #### Techniques for creating sequence diagrams (e.g. actors, objects, messages)
 <li>Lifeline represents an individual participant (or object) in the interaction</li>
 <li>Focus of control (activation) specifies a behavior or interaction within the lifeline also known as execution specification</li>
 <li>Message defines a particular communication between lifelines of an interaction</li><br>

  <b>1. Syntax/Notation Details</b>
    <ul><li>Each use case should have at least one sequence diagram that comprises normal flow and alternative flows, split only if it is cluttered to combine all.</li>
    <li>Focus on object interaction in the domain model (class diagram for analysis) for a particular use case.</li>
    <li>Refer to the use case description when creating a sequence diagram.</li>
    <li>It is not necessary to include boundary, controller, and data layer details that could be added in the design stage.</li>
    <li>Keep the diagram simple and easy to understand, using clear and concise notation.</li></ul>

  <b>2. Types of Message</b><br>
  • Synchronous:
– If a caller sends a synchronous message (in sequence), it must wait until the message is done before it proceeds with its business

  • Asynchronous: 
– If a caller sends an asynchronous message, it can continue processing and does not have to wait for a response
– Usually used in multithreaded applications and in message- oriented middleware
• Return message: 
– Return messages are an optional part of a sequence diagram
– The use of return messages depends on the level of detail/abstraction that is being modeled
– Return messages are useful if finer detail is required; otherwise, the invocation message is sufficient 
  <p align='center'><img src="https://support.bizzdesign.com/download/attachments/39814476/worddav669df1d6e1ac5266ad5312a65db0622d.png?version=1&modificationDate=1559903155886&api=v2"width="600" height="450"></p>
  <p>Iteration-Determines the number of time to repeat the contents of the box.</p>
    <p align='center'><img src="https://i.ibb.co/7yCN09M/Screenshot-2023-04-27-163753.png"width="600" height="450"></p>
  <p>Branching and Self-Delegation</p>
    <p align='center'><img src="https://i.ibb.co/JvmHMPn/Screenshot-2023-04-27-163819.png"width="600" height="450"></p>
  <p>Concurrency</p>
    <p align='center'><img src="https://i.ibb.co/3z8zXfP/Screenshot-2023-04-27-163833.png"width="600" height="450"></p>

- #### Best practices for creating effective sequence diagrams
  <ul><li>Each use case should have at least one sequence diagram that comprises normal flow and alternative flows, split only if it is cluttered to combine all.</li>
  <li>Focus on object interaction in the domain model (class diagram for analysis) for a particular use case.</li>
  <li>Refer to the use case description when creating a sequence diagram.</li>
  <li>It is not necessary to include boundary, controller, and data layer details that could be added in the design stage.</li>
  <li>Keep the diagram simple and easy to understand, using clear and concise notation.</li></ul>

---
  
### 5. State Chart/State Machine Diagram
  
- #### Definition and purpose of state chart/state machine diagrams
State chart/state machine diagrams are graphical models used to represent the behavior of a system or a process. They depict the states that an object or system can be in and the transitions that occur between these states based on some triggering event or condition.

The purpose of state chart/state machine diagrams is to provide a clear and concise representation of the behavior of a system. They are particularly useful for modeling complex systems with multiple states and transitions between them. By breaking down the system's behavior into a series of states and transitions, these diagrams can help identify potential problems or opportunities for optimization.

State chart/state machine diagrams can be used in a variety of contexts, including software engineering, control engineering, and business process modeling. In software engineering, they are commonly used to model the behavior of complex software systems. In control engineering, they are used to model the behavior of physical systems such as robots or automated machines. In business process modeling, they can be used to represent the workflow of a business process or a series of tasks performed by a team of people.

<p align='center'><img src="https://i.pinimg.com/originals/32/2d/b6/322db67f5f167d860263c9772f36a9c9.png"width="600" height="450"></p>
  
- #### Techniques for creating state chart/state machine diagrams (e.g. states, events, transitions)
1. Identify the states: Start by identifying the different states that the system or object can be in. States represent the conditions or modes of operation of the system or object. You can represent states as rectangles with rounded corners, and label them with descriptive names.
  
<p align='center'><img src="https://i.imgur.com/PE8fzwG.png"width="575" height="215"></p>
  
  State Syntax
<p align='center'><img src="https://i.imgur.com/HCEGUFX.png"width="600" height="350"></p>
  
2. Identify the events: Identify the events that can trigger transitions between the different states. Events can be external inputs, internal conditions, or a combination of both. You can represent events as arrows entering a state, and label them with descriptive names.
  
<p align='center'><img src="https://i.imgur.com/5j4PgXY.png"width="600" height="350"></p>

  Call Event State Chart
<p align='center'><img src="https://i.imgur.com/Fx64LP9.png"width="600" height="350"></p>
  
  Signal Event State Chart
<p align='center'><img src="https://i.imgur.com/pQieTCA.png"width="600" height="350"></p>
  
  Change Event State Chart
<p align='center'><img src="https://i.imgur.com/hWaHL0T.png"width="600" height="350"></p>
  
  Time Event State Chart
 <p align='center'><img src="https://i.imgur.com/kSUmGUc.png"width="600" height="350"></p>
  
3. Identify the transitions: Identify the conditions or actions that must be met or performed for a transition to occur between two states. Transitions represent the change in state that occurs when an event happens. You can represent transitions as arrows leaving a state, and label them with the name of the event that triggers them.
  
<p align='center'><img src="https://i.imgur.com/TN1YMKi.png"width="600" height="100"></p>
  
4. Define the actions: Identify the actions that need to be taken when a transition occurs, such as updating variables, sending messages, or invoking functions. You can represent actions as small rectangles within the transition arrows, and label them with descriptive names.
  
5. Add additional details: Add any additional details that may be helpful, such as constraints, guards, or triggers. Constraints represent conditions that must be satisfied for a transition to occur, guards represent conditions that must be satisfied for a transition to continue, and triggers represent actions that are performed when a transition occurs.
  
- #### Best practices for creating effective state chart/state machine diagrams

State charts or state machine diagrams are useful tools for visualizing the behavior of complex systems, processes, or software. Here are some best practices for creating effective state charts or state machine diagrams:
  
  <li> Keep it simple: State charts should be easy to read and understand. Avoid cluttering the diagram with unnecessary details, and use clear and concise labels for states and transitions.</li>
  <li> Use consistent notation: Use a consistent notation for representing states, transitions, and actions throughout the diagram. This will make the diagram easier to read and understand.</li>
  <li> Define clear states and transitions: Clearly define the states and transitions in the diagram, and make sure that they are meaningful and relevant to the system or process being modeled.</li>
  <li> Show the initial state: Include the initial state of the system or process being modeled in the diagram. This will help readers understand the starting point of the system or process.</li>
  <li> Include final states: If the system or process being modeled has a defined end state, include this in the diagram. This will help readers understand the final state of the system or process.</li>
  <li> Label transitions with events and actions: Label transitions with the events that trigger them, and the actions that result from them. This will make it clear what is happening in the system or process at each stage.</li>
  <li> Use hierarchies and orthogonal regions: If the system or process being modeled is complex, consider using hierarchies or orthogonal regions to organize the diagram. This will make it easier to understand and navigate.</li>
  <li> Validate the model: Once the state chart is complete, validate the model by checking that it accurately represents the behavior of the system or process being modeled.</li>
  
---

## III. Part II: Requirements Document
### A. Understanding the Requirements Document
- #### Definition of the requirements document
  <p>Software requirements document is an official statement of what is required for the reference of software developers</p>
  <p>Should include both definitions of user requirements and specifications of the system requirements</p>
  <p>It is NOT a design document</p>
  <p>As far as possible, it should set WHAT the system</p>
should do rather than HOW it should do it

- #### Importance of the requirements document in software development
 The requirements document is critical to the success of software development projects. It serves as a blueprint for the development team, providing a clear understanding of what needs to be built. When the requirements document is well-defined, it reduces misunderstandings and ambiguity, which can lead to costly delays and errors. By having a clear understanding of what the system needs to do, developers can focus on building software that meets the needs of the end-users.
 

- #### Key components of the requirements document

The key components of the requirements document may vary depending on the project's scope, but some common elements include:

-Executive Summary: A high-level summary of the requirements document, including the project's goals, objectives, and scope.

-User Requirements: A detailed description of what the end-users expect the system to do.

-Functional Requirements: A list of the system's features and functionalities, including input and output specifications.

-Non-functional Requirements: A list of system requirements that are not directly related to its functionality, such as performance, security, and usability.

-System Constraints: A list of limitations that may impact the development of the software, such as technical constraints, resource constraints, and regulatory requirements.

  
---

### B. Software Requirements Specification (SRS)
#### 1. Definition and purpose of SRS
A Software Requirements Specification (SRS) is a detailed description of the system's software requirements. It outlines the functional and non-functional requirements, system constraints, and any other important details that the development team needs to know to build the software. The SRS serves as a reference for developers, helping them understand what needs to be built and how it should be built.

#### 2. Importance of SRS in software development
The SRS is critical to the success of software development projects. It provides a detailed description of what the software needs to do, helping developers build software that meets the end-users' needs. It also serves as a communication tool between the development team and other stakeholders, such as project managers and quality assurance testers.

#### 3. Key components of SRS (e.g. functional requirements, non-functional requirements, system constraints)
The key components of an SRS document may vary depending on the project's scope, but some common elements include:

-Introduction: A brief overview of the project and the purpose of the SRS document.

-Functional Requirements: A detailed description of the system's features and functionalities, including inputs, outputs, and expected behavior.

-Non-functional Requirements: A list of requirements that are not directly related to the system's functionality, such as performance, security, and usability.

-System Constraints: A list of limitations that may impact the development of the software, such as technical constraints, resource constraints, and regulatory requirements.
User Requirements: A detailed description of what the end-users expect the system to do.


#### 4. Techniques for creating effective SRS documents

-Involve stakeholders: Involve stakeholders, including end-users, project managers, and developers, in the requirements gathering process to ensure that all requirements are captured.

-Use clear and concise language: Use simple language to ensure that everyone can understand the document's content.

-Be specific: Be specific when describing the system's requirements to avoid ambiguity and misunderstandings.

-Prioritize requirements: Prioritize requirements to ensure that the most critical requirements are addressed first.


#### 5. Best practices for reviewing and validating SRS documents
Reviewing and validating SRS documents is a critical step in the software development process. Here are some best practices for reviewing and validating SRS documents:

Use multiple reviewers: Have multiple reviewers, including stakeholders and subject matter experts, review the SRS document to ensure that all requirements are captured and understood.

-Testability: Ensure that each requirement is testable, meaning that it can be validated through testing.

-Consistency: Verify that the requirements are consistent with each other and with the project's goals and objectives.

-Traceability: Ensure that each requirement is traceable to a specific user need or business goal.


---

### C. Managing Changes to the Requirements Document
- #### Techniques for managing changes to the requirements document (e.g. traceability matrix, change control)
Changes to the requirements document are inevitable in the software development process. Here are some techniques for managing changes to the requirements document:

-Change Control: Establish a change control process to manage changes to the requirements document. This process should include procedures for documenting and tracking changes, as well as a mechanism for approving and implementing changes.

-Traceability Matrix: Create a traceability matrix to track the relationship between user requirements, functional requirements, and non-functional requirements. This matrix can help identify the impact of changes to specific requirements and facilitate decision-making.

-Version Control: Use version control tools to manage changes to the requirements document. This can help ensure that each version of the document is properly documented and tracked.


- #### Best practices for managing changes to the requirements document
 Managing changes to the requirements document can be a challenging task. Here are some best practices for managing changes to the requirements document:

-Establish clear communication: Ensure that all stakeholders are informed of changes to the requirements document and understand the impact of those changes on the project.

-Prioritize changes: Prioritize changes to the requirements document based on their impact on the project and the level of effort required to implement them.

-Document changes: Document all changes to the requirements document, including the reason for the change and the impact on the project.

-Re-validate requirements: Re-validate the requirements document after making changes to ensure that it still meets the end-users' needs and the project's goals and objectives.



## Contribution 🛠️
Please create an [Issue](https://github.com/drshahizan/software-engineering/issues) for any improvements, suggestions or errors in the content.

You can also contact me using [Linkedin](https://www.linkedin.com/in/drshahizan/) for any other queries or feedback.

![](https://komarev.com/ghpvc/?username=drshahizan&label=Views&color=0e75b6&style=flat)
![](https://hit.yhype.me/github/profile?user_id=81284918)


